#include "ospfinc.h"
#include "monitor.h"
#include "system.h"
#include "ifcfsm.h"
#include "nbrfsm.h"
#include "phyint.h"

/* Constructor for the ABR-LSA. We use the ABR-LSAs advertising router
 * as the unique key for the AVLitem, as we should only have one ABR-LSA
 * stored per existing ABR, generated by that same router.
 */

overlayAbrLSA::overlayAbrLSA(opqLSA *opq)
 : PriQElt(), AVLitem(opq->adv_rtr(), 0) 
{
    lsa = opq;
    ospf->abrLSAs.add(this);
}

/* Destructor for the ABR-LSA
 */

overlayAbrLSA::~overlayAbrLSA()
{
    ospf->abrLSAs.remove(this);
}

/* Constructor for the Prefix-LSA
 */

overlayPrefixLSA::overlayPrefixLSA(opqLSA *opq, Prefixhdr p)
 : AVLitem(opq->adv_rtr(), 0)
//TODO define prefix diferentiator, for AVLtree (maybe full Prefixhdr struct in bytes????)
{
    lsa = opq;
    prefix = p;
    ospf->prefixLSAs.add(this);
}

/* Destructor for the Prefix-LSA
 */

overlayPrefixLSA::~overlayPrefixLSA()
{
    ospf->prefixLSAs.remove(this);
}

/* Constructor for the ASBR-LSA
 */

overlayAsbrLSA::overlayAsbrLSA(opqLSA *opq, ASBRhdr a)
 : AVLitem(opq->adv_rtr(), 0)
//TODO define ASBR diferentiator, for AVLtree (maybe full ASBRhdr struct in bytes????)
{
    lsa = opq;
    asbr = a;
    ospf->asbrLSAs.add(this);
}

/* Destructor for the ASBR-LSA
 */

overlayAsbrLSA::~overlayAsbrLSA()
{
    ospf->asbrLSAs.remove(this);
}

/* Constructor for the ABRNbr class. The area in which we are neighbors
 * with this ABR is used as a diferentiator for different objects
 * created for the same router. This is needed to store different possible
 * costs to the same ABR.
 */

ABRNbr::ABRNbr(rtid_t id, rtrLSA *lsa, SpfArea *a) : AVLitem(id, a->id()) {
    rid = id;
    rtr = lsa;
    cost = LSInfinity;
    area = a;
    ospf->ABRNbrs.add(this);
}

/* Destructor for the ABRNbr class
 */

ABRNbr::~ABRNbr() {
    ospf->ABRNbrs.remove(this);
    rtr->abr = 0;
}

/* We remove this neighbor ABR from our list of ABR overlay neighbors.
 * Also, we remove the link to this ABRNbr instance from the
 * corresponding Router-LSA.
 */

void ABRNbr::remove_abr_nb() {
    ospf->ABRNbrs.remove(this);
    rtr->abr = 0;
}

/* Add an ABR to OSPF. If already added, return it. Otherwise
 * allocate entry and add it to the AVL and singly linked list.
 * Similar to the method with the same name used inside the areas,
 * but to be used by the overlay ABRs.
 */

RTRrte *OSPF::add_abr(uns32 rtrid)

{
    RTRrte *rte;

    if ((rte = (RTRrte *) ABRtree.find(rtrid)))
        return(rte);
    
    rte = new RTRrte(rtrid, 0);
    ABRtree.add(rte);
    return(rte);
}

/* We originate and flood our ABR-LSA inside an Opaque-LSA with
 * AS-scope. We go through all our ABR neighbors to whom the intra-area
 * shortest path cost has already been determined. We iterate through
 * two lists:
 *      - First, we go through all the entries for the ABRNbrs. Here
 *      we compare these entries to get only the lower cost entry for
 *      each neighboring ABR. The best option to each ABR is then stored
 *      in a separate list.
 *      - Then, we iterate through the list created that contains the
 *      lower path cost option to each ABR, to build the ABR-LSA.
 */

void OSPF::orig_abrLSA() {
    ABRNbr *abrNbr, *abr;
    ABRhdr *body;
    byte *body_start;
    int blen;
    lsid_t lsid;
    uns32 cost;
    uns32 rid;

    abr_changed = false;
    added_nbrs.clear();
    lsid = OPQ_T_MULTI_ABR << 24;
    body = (ABRhdr *) body_start;

    // Iterate through all ABR neighbor entries
    abrNbr = (ABRNbr *) ABRNbrs.sllhead;
    for (; abrNbr; abrNbr = (ABRNbr *) abrNbr->sll) {
        cost = abrNbr->cost;
        rid = abrNbr->rid;
        // Cost is assigned, so we add to the LSA
        if (cost < LSInfinity) {
            // Entry already added
            if ((abr = (ABRNbr *) added_nbrs.find(rid))) {
                // Make sure it returns the correct one
                if (abr->get_rid() == rid) {
                    // There is an entry for this ABR with a lower or equal cost
                    if (abr->get_cost() <= cost) {
                        continue;
                    }
                }
            }
            // New neighbor
            added_nbrs.add(abrNbr);
        }
    }

    // Add only the lower cost entries
    abrNbr = (ABRNbr *) added_nbrs.sllhead;
    for (; abrNbr; abrNbr = (ABRNbr *) abrNbr->sll) {
        body->metric = hton32(abrNbr->cost);
        body->neigh_rid = hton32(abrNbr->rid);
        body++;
    }

    blen = added_nbrs.size() * sizeof(ABRhdr);
    if (blen > 0)
        opq_orig(0, 0, LST_AS_OPQ, lsid, body_start, blen, true, 1);
}

/* Parse a received overlay-LSA.
 * This LSA can either be:
 *      - ABR-LSA
 *      - Prefix-LSA
 *      - ASBR-LSA
 */

void opqLSA::parse_overlay_lsa(LShdr *hdr) {
    // ABR-LSA
    if (ls_id() == (OPQ_T_MULTI_ABR<<24)) {
        overlayAbrLSA *abrLSA;

        // We check if there is a stored ABR-LSA for this opaque-LSA
        if (!(abrLSA = (overlayAbrLSA *) ospf->abrLSAs.find(adv_rtr()))) {
            abrLSA = new overlayAbrLSA(this);
        }

        ABRhdr *abrhdr;
        byte *end;

        abrhdr = (ABRhdr *) (hdr+1);
        end = ((byte *) hdr) + ntoh16(hdr->ls_length);

        abrLSA->t_dest = ospf->add_abr(adv_rtr());
        abrLSA->nbrs = abrhdr;
        abrLSA->n_nbrs = (ntoh16(hdr->ls_length) - sizeof(LShdr))/sizeof(ABRhdr);
    }
    // Prefix-LSA
    else if (ls_id() == (OPQ_T_MULTI_PREFIX<<24)) {

    }
    // ASBR-LSA
    else if (ls_id() == (OPQ_T_MULTI_ASBR<<24)) {

    }
}

/* Unparse an overlay-LSA
 */

void opqLSA::unparse_overlay_lsa() {
    // ABR-LSA
    if (ls_id() == (OPQ_T_MULTI_ABR<<24)) {
        overlayAbrLSA *abrLSA;
        // We check if there is a stored ABR-LSA for this opaque-LSA
        if ((abrLSA = (overlayAbrLSA *) ospf->abrLSAs.find(adv_rtr()))) {
            abrLSA->t_dest = 0;
            abrLSA->n_nbrs = 0;
        }
    }
    // Prefix-LSA
    else if (ls_id() == (OPQ_T_MULTI_PREFIX<<24)) {

    }
    // ASBR-LSA
    else if (ls_id() == (OPQ_T_MULTI_ASBR<<24)) {

    }
}




/* Generate and send the Prefix-LSA with AS-scope
 */

void OSPF::send_prefix_lsa(INrte *rte) {
    //TODO flag on the routes indicating it should be advertised in a prefix-LSA??? might be easier to go through them, rather than checking for every one
    Prefixhdr *body;
    lsid_t ls_id;
    uns32 cost;
    
    if (rte == default_route) // skip default route
        return;
    
    if (rte->cost == LSInfinity) // skip unreachable routes
        return;
    
    cost = rte->cost;

    // Build the LSA body
    ls_id = OPQ_T_MULTI_PREFIX << 24;

    body->metric = hton32(cost);
    printf("cost done\n");
    body->subnet_mask = hton32(rte->mask());
    printf("mask done\n");
    body->subnet_addr = hton32(rte->net());
    printf("addr done\n");

    rte->advertise_overlay();

    adv_as_opq(ls_id, (byte *) body, sizeof(Prefixhdr), true, 1);
}

/* Generate and send the ASBR-LSA with AS-scope
 */

void OSPF::send_asbr_lsa(ASBRrte *rte) { 
    //TODO flag on the routes indicating it should be advertised in an asbr-LSA???
    ASBRhdr *body;
    lsid_t ls_id;

    // Build the LSA body
    ls_id = OPQ_T_MULTI_ASBR << 24;
    
    body->metric = rte->cost;
    body->dest_rid = rte->rtrid();
    rte->advertise_overlay();

    adv_as_opq(ls_id, (byte *) body, sizeof(ASBRhdr), true, 1);
}