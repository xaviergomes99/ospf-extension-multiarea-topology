#include "ospfinc.h"
#include "monitor.h"
#include "system.h"
#include "ifcfsm.h"
#include "nbrfsm.h"
#include "phyint.h"

/* Constructor for the ABR-LSA. We use the ABR-LSAs advertising router
 * as the unique key for the AVLitem, as we should only have one ABR-LSA
 * stored per existing ABR, generated by that same router.
 */

overlayAbrLSA::overlayAbrLSA(opqLSA *opq)
 : PriQElt(), AVLitem(opq->adv_rtr(), 0) 
{
    lsa = opq;
    opq->abrLSA = this;
    ospf->abrLSAs.add(this);
}

/* Destructor for the ABR-LSA
 */

overlayAbrLSA::~overlayAbrLSA()
{
    ospf->abrLSAs.remove(this);
}

/* Constructor for the Prefix-LSA
 */

overlayPrefixLSA::overlayPrefixLSA(opqLSA *opq, Prefixhdr *p)
 : AVLitem(opq->adv_rtr(), (p->subnet_addr & p->subnet_mask)) 

{
    lsa = opq;
    opq->prefixLSA = this;
    prefix = p;
    ospf->prefixLSAs.add(this);
}

/* Destructor for the Prefix-LSA
 */

overlayPrefixLSA::~overlayPrefixLSA()
{
    ospf->prefixLSAs.remove(this);
}

/* Constructor for the ASBR-LSA
 */

overlayAsbrLSA::overlayAsbrLSA(opqLSA *opq, ASBRhdr *a)
 : AVLitem(opq->adv_rtr(), a->dest_rid)

{
    lsa = opq;
    opq->asbrLSA = this;
    asbr = a;
    ospf->asbrLSAs.add(this);
}

/* Destructor for the ASBR-LSA
 */

overlayAsbrLSA::~overlayAsbrLSA()
{
    ospf->asbrLSAs.remove(this);
}

/* Constructor for the ABRNbr class. The area in which we are neighbors
 * with this ABR is used as a diferentiator for different objects
 * created for the same router. This is needed to store different possible
 * costs to the same ABR.
 */

ABRNbr::ABRNbr(rtid_t id, rtrLSA *lsa, SpfArea *a) : AVLitem(id, a->id()) {
    rid = id;
    rtr = lsa;
    cost = LSInfinity;
    area = a;
    ospf->ABRNbrs.add(this);
}

/* Destructor for the ABRNbr class
 */

ABRNbr::~ABRNbr() {
    ospf->ABRNbrs.remove(this);
    rtr->abr = 0;
}

/* We remove this neighbor ABR from our list of ABR overlay neighbors.
 * Also, we remove the link to this ABRNbr instance from the
 * corresponding Router-LSA.
 */

void ABRNbr::remove_abr_nb() {
    ospf->ABRNbrs.remove(this);
    rtr->abr = 0;
}

/* Add an ABR to OSPF. If already added, return it. Otherwise
 * allocate entry and add it to the AVL and singly linked list.
 * Similar to the method with the same name used inside the areas,
 * but to be used by the overlay ABRs.
 */

RTRrte *OSPF::add_abr(uns32 rtrid)

{
    RTRrte *rte;

    if ((rte = (RTRrte *) ABRtree.find(rtrid)))
        return(rte);
    
    rte = new RTRrte(rtrid, 0);
    ABRtree.add(rte);
    return(rte);
}

/* We originate and flood our ABR-LSA inside an Opaque-LSA with
 * AS-scope. We go through all our ABR neighbors to whom the intra-area
 * shortest path cost has already been determined. We iterate through
 * two lists:
 *      - First, we go through all the entries for the ABRNbrs. Here
 *      we compare these entries to get only the lower cost entry for
 *      each neighboring ABR. The best option to each ABR is then stored
 *      in a separate list.
 *      - Then, we iterate through the list created that contains the
 *      lower path cost option to each ABR, to build the ABR-LSA.
 */

void OSPF::orig_abrLSA() {
    ABRNbr *abrNbr, *abr;
    ABRhdr *body, curr, body_start;
    int blen;
    lsid_t lsid;
    uns32 cost;
    uns32 rid;

    abr_changed = false;
    added_nbrs.clear();
    lsid = OPQ_T_MULTI_ABR << 24;
    body = &body_start;

    // Iterate through all ABR neighbor entries
    abrNbr = (ABRNbr *) ABRNbrs.sllhead;
    for (; abrNbr; abrNbr = (ABRNbr *) abrNbr->sll) {
        cost = abrNbr->cost;
        rid = abrNbr->rid;
        // Cost is assigned, so we add to the LSA
        if (cost < LSInfinity) {
            // Entry already added
            if ((abr = (ABRNbr *) added_nbrs.find(rid))) {
                // Make sure it returns the correct one
                if (abr->get_rid() == rid) {
                    // There is an entry for this ABR with a lower or equal cost
                    if (abr->get_cost() <= cost) {
                        continue;
                    }
                }
            }
            // New neighbor
            added_nbrs.add(abrNbr);
        }
    }

    // Add only the lower cost entries
    abrNbr = (ABRNbr *) added_nbrs.sllhead;
    for (; abrNbr; abrNbr = (ABRNbr *) abrNbr->sll) {
        curr.metric = abrNbr->cost;
        curr.neigh_rid = hton32(abrNbr->rid);
        memcpy(body, &curr, sizeof(ABRhdr));
        body++;
    }

    blen = added_nbrs.size() * sizeof(ABRhdr);
    if (blen > 0) {
        opq_orig(0, 0, LST_AS_OPQ, lsid, (byte *) &body_start, blen, true, 1);
        if (!first_abrLSA_sent) {
            first_abrLSA_sent = true;
            send_all_prefixes = true;
        }
    }
}

/* For a given routing table entry (referring to an intra-area destination)
 * we originate a Prefix-LSA and advertise it as an Opaque-LSA.
 */

void OSPF::orig_prefixLSA(INrte *rte) {
    Prefixhdr body;
    lsid_t lsid;

    lsid = (OPQ_T_MULTI_PREFIX << 24) | ((rte->uid << 8) >> 8);

    body.metric = rte->cost;
    body.subnet_addr = hton32(rte->net());
    body.subnet_mask = hton32(rte->mask());

    opq_orig(0, 0, LST_AS_OPQ, lsid, (byte *) &body, sizeof(Prefixhdr), true, 1);
}

/* For a given ASBR (reachable through an area we are attached to)
 * we originate an ASBR-LSA and advertise it as an Opaque-LSA.
 */

void OSPF::orig_asbrLSA(ASBRrte *rte) {
    ASBRhdr body;
    lsid_t lsid;

    lsid = (OPQ_T_MULTI_ASBR << 24) | ((rte->uid << 8) >> 8);

    body.metric = rte->cost;
    body.dest_rid = hton32(rte->rtrid());

    opq_orig(0, 0, LST_AS_OPQ, lsid, (byte *) &body, sizeof(ASBRhdr), true, 1);
}

/* We advertise all the current intra-area routes to prefixes and ASBRs
 * into the ABR overlay. We do that by (re)originating every Prefix-LSA and
 * ASBR-LSA available.
 */

void OSPF::advertise_all_prefixes() {
    INrte *rte;
    INiterator iter(inrttbl);
    ASBRrte *asbr;

    // We advertise our intra-area prefixes
    while ((rte = iter.nextrte())) {
        if ((rte->adv_overlay) && (rte->type() == RT_SPF))
            orig_prefixLSA(rte);
    }

    // We also advertise all routes to intra-area reachable ASBRs
    for (asbr = ASBRs; asbr; asbr = asbr->next()) {
        if ((asbr->adv_overlay) && (asbr->type() == RT_SPF))
            orig_asbrLSA(asbr);
    }

    ospf->send_all_prefixes = false;
}

/* Parse a received overlay-LSA.
 * This LSA can either be:
 *      - ABR-LSA
 *      - Prefix-LSA
 *      - ASBR-LSA
 */

void opqLSA::parse_overlay_lsa(LShdr *hdr) {
    // ABR-LSA
    if ((ls_id()>>24) == OPQ_T_MULTI_ABR) {
        overlayAbrLSA *abrLSA;

        if (!(abrLSA = (overlayAbrLSA *) ospf->abrLSAs.find(adv_rtr()))) {
            abrLSA = new overlayAbrLSA(this);
        }

        this->abrLSA = abrLSA;

        ABRhdr *abrhdr;
        byte *end;

        abrhdr = (ABRhdr *) (hdr+1);
        end = ((byte *) hdr) + ntoh16(hdr->ls_length);

        abrLSA->t_dest = ospf->add_abr(adv_rtr());
        abrLSA->nbrs = abrhdr;
        abrLSA->n_nbrs = (ntoh16(hdr->ls_length) - sizeof(LShdr))/sizeof(ABRhdr);
    }
    // Prefix-LSA
    else if ((ls_id()>>24) == OPQ_T_MULTI_PREFIX) {
        overlayPrefixLSA *prefLSA;
        Prefixhdr *prefhdr;

        prefhdr = (Prefixhdr *) (hdr+1);

        if (!(prefLSA = (overlayPrefixLSA *) ospf->prefixLSAs.find(adv_rtr(), (prefhdr->subnet_addr & prefhdr->subnet_mask)))) {
            prefLSA = new overlayPrefixLSA(this, prefhdr);
        }

        this->prefixLSA = prefLSA;

        prefLSA->rte = inrttbl->add(prefhdr->subnet_addr, prefhdr->subnet_mask);
        prefLSA->prefix = prefhdr;
    }
    // ASBR-LSA
    else if ((ls_id()>>24) == OPQ_T_MULTI_ASBR) {
        overlayAsbrLSA *asbrLSA;
        ASBRhdr *asbrhdr;

        asbrhdr = (ASBRhdr *) (hdr+1);

        if (!(asbrLSA = (overlayAsbrLSA *) ospf->asbrLSAs.find(adv_rtr(), asbrhdr->dest_rid))) {
            asbrLSA = new overlayAsbrLSA(this, asbrhdr);
        }

        this->asbrLSA = asbrLSA;

        asbrLSA->rte = ospf->add_asbr(asbrhdr->dest_rid);
        asbrLSA->asbr = asbrhdr;
    }
}

/* Unparse an overlay-LSA
 */

void opqLSA::unparse_overlay_lsa() {
    // ABR-LSA
    if ((ls_id()>>24) == OPQ_T_MULTI_ABR) {
        abrLSA->t_dest = 0;
        abrLSA->n_nbrs = 0;
        abrLSA->nbrs = 0;
        abrLSA = 0;
    }
    // Prefix-LSA
    else if ((ls_id()>>24) == OPQ_T_MULTI_PREFIX) {
        prefixLSA->rte = 0;
        prefixLSA->prefix = 0;
        prefixLSA = 0;
    }
    // ASBR-LSA
    else if ((ls_id()>>24) == OPQ_T_MULTI_ASBR) {
        asbrLSA->rte = 0;
        asbrLSA->asbr = 0;
        asbrLSA = 0;
    }
}