#include "ospfinc.h"
#include "monitor.h"
#include "system.h"
#include "ifcfsm.h"
#include "nbrfsm.h"
#include "phyint.h"

/* Constructor for the ABRrte
 */

ABRrte::ABRrte(uns32 _id) : RTE(_id, 0) 
{
}

/* Constructor for the ABR-LSA. We use the ABR-LSAs advertising router
 * as the unique key for the AVLitem, as we should only have one ABR-LSA
 * stored per existing ABR, generated by that same router.
 */

overlayAbrLSA::overlayAbrLSA(opqLSA *opq)
 : PriQElt(), AVLitem(opq->adv_rtr(), 0) 
{
    lsa = opq;
    opq->abrLSA = this;
    cost = LSInfinity;
    ospf->abrLSAs.add(this);
    t_parent = 0;
    next_abr_hop = 0;
    nbrs = 0;
}

/* Destructor for the ABR-LSA
 */

overlayAbrLSA::~overlayAbrLSA()
{
    ospf->abrLSAs.remove(this);
}

/* Constructor for the ABR-LSA body item
 */

AbrLSAItem::AbrLSAItem()
{
    next = 0;
    prev = 0;
}

/* Destructor for the ABR-LSA body item
 */

AbrLSAItem::~AbrLSAItem()
{
    if (prev)
        prev->next = next;
}

/* Constructor for the Prefix-LSA
 */

overlayPrefixLSA::overlayPrefixLSA(opqLSA *opq, Prefixhdr *p)
 : AVLitem(opq->adv_rtr(), (p->subnet_addr & p->subnet_mask)) 

{
    lsa = opq;
    opq->prefixLSA = this;
    prefix = *p;
    ospf->prefixLSAs.add(this);
}

/* Destructor for the Prefix-LSA
 */

overlayPrefixLSA::~overlayPrefixLSA()
{
    ospf->prefixLSAs.remove(this);
}

/* Constructor for the ASBR-LSA
 */

overlayAsbrLSA::overlayAsbrLSA(opqLSA *opq, ASBRhdr *a)
 : AVLitem(opq->adv_rtr(), a->dest_rid)

{
    lsa = opq;
    opq->asbrLSA = this;
    asbr = *a;
    ospf->asbrLSAs.add(this);
}

/* Destructor for the ASBR-LSA
 */

overlayAsbrLSA::~overlayAsbrLSA()
{
    ospf->asbrLSAs.remove(this);
}

/* Constructor for the ABRNbr class. The area in which we are neighbors
 * with this ABR is used as a diferentiator for different objects
 * created for the same router. This is needed to store different possible
 * costs to the same ABR.
 */

ABRNbr::ABRNbr(rtrLSA *lsa, SpfArea *a) : AVLitem(lsa->adv_rtr(), a->id()) {
    rid = lsa->adv_rtr();
    rtr = lsa;
    cost = LSInfinity;
    area = a;
    use_in_lsa = false;
    rtr->abr = this;
    ospf->ABRNbrs.add(this);
}

/* Destructor for the ABRNbr class
 */

ABRNbr::~ABRNbr() {}

/* We remove this neighbor ABR from our list of ABR overlay neighbors.
 * Also, we remove the link to this ABRNbr instance from the
 * corresponding Router-LSA.
 */

// void ABRNbr::remove_abr_nb() {
//     // rtr->abr = 0;
//     rtr = 0;
//     area = 0;
//     ospf->abr_changed = true;
//     ospf->ABRNbrs.remove(this);
//     if (ospf->ABRNbrs.size() == 0 && ospf->my_abr_lsa) {
//         ospf->my_abr_lsa->lsa->adv_opq = false;
//         ospf->my_abr_lsa->lsa->reoriginate(false);
//         ospf->first_abrLSA_sent = false;
//         ospf->my_abr_lsa = 0;
//     }
// }

/* Add an ABR to OSPF. If already added, return it. Otherwise
 * allocate entry and add it to the AVL and singly linked list.
 * Similar to the method with the same name used inside the areas,
 * but to be used by the overlay ABRs.
 */

ABRrte *OSPF::add_abr(uns32 rtrid)

{
    ABRrte *rte;

    if ((rte = (ABRrte *) ABRtree.find(rtrid)))
        return(rte);
    
    rte = new ABRrte(rtrid);
    ABRtree.add(rte);
    return(rte);
}

/* We originate and flood our ABR-LSA inside an Opaque-LSA with
 * AS-scope. We go through all our ABR neighbors to whom the intra-area
 * shortest path cost has already been determined. We iterate through
 * two lists:
 *      - First, we go through all the entries for the ABRNbrs. Here
 *      we compare these entries to get only the lower cost entry for
 *      each neighboring ABR. The best option to each ABR is then stored
 *      in a separate list.
 *      - Then, we iterate through the list created that contains the
 *      lower path cost option to each ABR, to build the ABR-LSA.
 */

void OSPF::orig_abrLSA() {
    ABRNbr *abrNbr, *abrInLsa;
    ABRhdr *body, curr;
    int blen;
    lsid_t lsid;
    uns32 cost;
    bool found;
    int n_added = 0;

    abr_changed = false;
    lsid = OPQ_T_MULTI_ABR << 24;
    body = &body_start;

    // Clear previous additions
    abrNbr = (ABRNbr *) ABRNbrs.sllhead;
    for (; abrNbr; abrNbr = (ABRNbr *) abrNbr->sll) {
        abrNbr->use_in_lsa = false;
    }

    // Iterate through all ABR neighbor entries
    abrNbr = (ABRNbr *) ABRNbrs.sllhead;
    for (; abrNbr; abrNbr = (ABRNbr *) abrNbr->sll) {
        cost = abrNbr->cost;
        // Cost is assigned, so we add to the LSA
        if (cost < LSInfinity) {
            found = false;
            abrInLsa = (ABRNbr *) ABRNbrs.sllhead;
            for (; abrInLsa; abrInLsa = (ABRNbr *) abrInLsa->sll) {
                // There is already an entry for this ABR
                if ((abrInLsa->get_rid() == abrNbr->rid) && abrInLsa->use_in_lsa) {
                    found = true;
                    // There is an entry for this ABR with a lower cost
                    if (abrInLsa->get_cost() >= cost) {
                        abrInLsa->use_in_lsa = false;
                        abrNbr->use_in_lsa = true;
                    }
                    break;
                }
            }
            // New neighbor
            if (!found) {
                abrNbr->use_in_lsa = true;
                n_added++;
            }
        }
    }

    // Add only the lower cost entries
    abrNbr = (ABRNbr *) ABRNbrs.sllhead;
    for (; abrNbr; abrNbr = (ABRNbr *) abrNbr->sll) {
        if (abrNbr->use_in_lsa) {
            curr.metric = abrNbr->cost;
            curr.neigh_rid = ntoh32(abrNbr->rid);
            memcpy(body, &curr, sizeof(ABRhdr));
            body++;
        }
    }

    blen = n_added * sizeof(ABRhdr);
    if (blen > 0) {
        opq_orig(0, 0, LST_AS_OPQ, lsid, (byte *) &body_start, blen, true, 0);
        // This is the first ABR-LSA we are sending out
        if (!first_abrLSA_sent) {
            first_abrLSA_sent = true;
            // parse_delayed_lsas();
            send_all_prefixes = true;
        }
    }
    // No neighbors have been added, so we clear the ABRNbr list
    else if (first_abrLSA_sent) {
        abrNbr = (ABRNbr *) ABRNbrs.sllhead;
        for (; abrNbr; abrNbr = (ABRNbr *) abrNbr->sll) {
            abrNbr->rtr->abr = 0;
        }
        ABRNbrs.clear();
        ospf->my_abr_lsa->lsa->adv_opq = false;
        ospf->my_abr_lsa->lsa->reoriginate(false);
        ospf->first_abrLSA_sent = false;
        ospf->my_abr_lsa = 0;
    }
}

/* For a given routing table entry (referring to an intra-area destination)
 * we originate a Prefix-LSA and advertise it as an Opaque-LSA.
 */

void OSPF::orig_prefixLSA(INrte *rte) {
    Prefixhdr body;
    lsid_t lsid;

    lsid = (OPQ_T_MULTI_PREFIX << 24) | ((rte->uid << 8) >> 8);

    body.metric = rte->intra_cost;
    body.subnet_addr = hton32(rte->net());
    body.subnet_mask = hton32(rte->mask());

    opq_orig(0, 0, LST_AS_OPQ, lsid, (byte *) &body, sizeof(Prefixhdr), true, 0);
}

/* For a given ASBR (reachable through an area we are attached to)
 * we originate an ASBR-LSA and advertise it as an Opaque-LSA.
 */

void OSPF::orig_asbrLSA(ASBRrte *rte) {
    ASBRhdr body;
    lsid_t lsid;

    lsid = (OPQ_T_MULTI_ASBR << 24) | ((rte->uid << 8) >> 8);

    body.metric = rte->intra_cost;
    body.dest_rid = hton32(rte->rtrid());

    opq_orig(0, 0, LST_AS_OPQ, lsid, (byte *) &body, sizeof(ASBRhdr), true, 0);
}

/* We advertise all the current intra-area routes to prefixes and ASBRs
 * into the ABR overlay. We do that by (re)originating every Prefix-LSA and
 * ASBR-LSA available.
 */

void OSPF::advertise_all_prefixes() {
    INrte *rte;
    INiterator iter(inrttbl);
    ASBRrte *asbr;

    // We advertise our intra-area prefixes
    while ((rte = iter.nextrte())) {
        if ((rte->adv_overlay) &&
            (rte->has_intra_path && rte->intra_cost != LSInfinity))
            orig_prefixLSA(rte);
    }

    // We also advertise all routes to intra-area reachable ASBRs
    for (asbr = ASBRs; asbr; asbr = asbr->next()) {
        if ((asbr->adv_overlay) && 
            (asbr->has_intra_path && rte->intra_cost != LSInfinity))
            orig_asbrLSA(asbr);
    }

    ospf->send_all_prefixes = false;
}

/* Parse the overlay LSAs that have been delayed since we hadn't yet send
 * our own ABR-LSA out yet.
 */

// void OSPF::parse_delayed_lsas() 

// {
//     opqLSA *lsa;

//     lsa = (opqLSA *) ASOpqLSAs.sllhead;
//     for (; lsa; lsa = (opqLSA *) lsa->sll) {
//         if (lsa->delay) {
//             lsa->delay = false;
//             if (lsa->abrLSA) {
//                 calc_overlay = true;
//             }
//             else if (lsa->prefixLSA) {
//                 if ((n_overlay_dijkstras > 0)) {
//                     adv_best_prefix(lsa->prefixLSA->rte);
//                     fa_tbl->resolve();
//                 }
//                 else 
//                     lsa->delay = true;
//             }
//         }
//     }
// }

/* Parse a received overlay-LSA.
 * This LSA can either be:
 *      - ABR-LSA
 *      - Prefix-LSA
 *      - ASBR-LSA
 * When parsing the LSA, we create the corresponding class object, if it doesn't
 * yet exist, in order to store the data from the LSA in a more useful manner
 */

void opqLSA::parse_overlay_lsa(LShdr *hdr) {
    // ABR-LSA
    if ((ls_id()>>24) == OPQ_T_MULTI_ABR) {
        overlayAbrLSA *abrLSA;

        if (!(abrLSA = (overlayAbrLSA *) ospf->abrLSAs.find(adv_rtr()))) {
            abrLSA = new overlayAbrLSA(this);
        }

        this->abrLSA = abrLSA;
        abrLSA->n_nbrs = (ntoh16(hdr->ls_length) - sizeof(LShdr))/sizeof(ABRhdr);
        
        // Update first neighbor structure
        ABRhdr *body = (ABRhdr *) (hdr + 1);
        AbrLSAItem *curr;
        if (!abrLSA->nbrs)
            abrLSA->nbrs = new AbrLSAItem();
        curr = abrLSA->nbrs;
        curr->nbr.metric = body->metric;
        curr->nbr.neigh_rid = hton32(body->neigh_rid);
        body++;

        // Update possible subsequent neighbors 
        int i;
        for (i = 1; i < abrLSA->n_nbrs; i++, body++) {
            if (!curr->next)
                curr->next = new AbrLSAItem();
            curr->next->prev = curr;
            curr = curr->next;
            curr->nbr.metric = body->metric;
            curr->nbr.neigh_rid = hton32(body->neigh_rid);
        }

        if (adv_rtr() == ospf->my_id())
            ospf->my_abr_lsa = abrLSA;
        
        if (ospf->first_abrLSA_sent)
            ospf->calc_overlay = true;
    }
    // Prefix-LSA
    else if ((ls_id()>>24) == OPQ_T_MULTI_PREFIX) {
        overlayPrefixLSA *prefLSA;
        Prefixhdr *prefhdr;

        prefhdr = (Prefixhdr *) (hdr+1);

        if (!(prefLSA = (overlayPrefixLSA *) ospf->prefixLSAs.find(adv_rtr(), (prefhdr->subnet_addr & prefhdr->subnet_mask)))) {
            prefLSA = new overlayPrefixLSA(this, prefhdr);
        }

        this->prefixLSA = prefLSA;

        prefLSA->rte = inrttbl->add(ntoh32(prefhdr->subnet_addr), ntoh32(prefhdr->subnet_mask));
        prefLSA->prefix = *prefhdr;

        // Link this prefix-LSA to the list of prefix-LSAs associated to this prefix
        prefLSA->link = prefLSA->rte->prefixes;
        prefLSA->rte->prefixes = prefLSA;

        // Originate the corresponding summ-LSA, if there isn't a full overlay calculation scheduled
        if (ospf->first_abrLSA_sent && (ospf->n_overlay_dijkstras > 0)) {
            ospf->adv_best_prefix(prefLSA->rte);
            fa_tbl->resolve();
        }
        else {
            prefLSA->rte->has_been_adv = false;
        }
        // else {
        //     delay = true;
        // }
    }
    // ASBR-LSA
    else if ((ls_id()>>24) == OPQ_T_MULTI_ASBR) {
        overlayAsbrLSA *asbrLSA;
        ASBRhdr *asbrhdr;

        asbrhdr = (ASBRhdr *) (hdr+1);

        if (!(asbrLSA = (overlayAsbrLSA *) ospf->asbrLSAs.find(adv_rtr(), asbrhdr->dest_rid))) {
            asbrLSA = new overlayAsbrLSA(this, asbrhdr);
        }

        this->asbrLSA = asbrLSA;

        asbrLSA->rte = ospf->add_asbr(asbrhdr->dest_rid);
        asbrLSA->asbr = *asbrhdr;

        asbrLSA->link = asbrLSA->rte->asbr_lsas;
        asbrLSA->rte->asbr_lsas = asbrLSA;

        // Originate the corresponding ASBR-Summ-LSA, if there isn't a 
        // full overlay calculation scheduled
        if (ospf->first_abrLSA_sent && !ospf->calc_overlay && (ospf->n_overlay_dijkstras > 0)) {
            ospf->adv_best_asbr(asbrLSA->rte);
            fa_tbl->resolve();
        }
    }
}

/* Unparse an overlay-LSA
 */

void opqLSA::unparse_overlay_lsa() {
    // ABR-LSA
    if ((ls_id()>>24) == OPQ_T_MULTI_ABR) {
        abrLSA->n_nbrs = 0;
        abrLSA->nbrs = 0;
        abrLSA = 0;
    }
    // Prefix-LSA
    else if ((ls_id()>>24) == OPQ_T_MULTI_PREFIX) {
        overlayPrefixLSA *ptr, *pref = prefixLSA;
        overlayPrefixLSA **prev;
        bool this_pref = false;

        if (!pref->rte) {
            prefixLSA->rte = 0;
            prefixLSA = 0;
            return;
        }

        if (pref->rte->in_use == pref) {
            this_pref = true;
            pref->rte->in_use = 0;
        }

        // Unlink from list in RTE
        for (prev = &pref->rte->prefixes; (ptr = *prev); prev = (overlayPrefixLSA **)&ptr->link) {
            if (*prev == pref) {
	            *prev = (overlayPrefixLSA *) pref->link;
	            break;
	        }
        }

        // Check if there are still prefixes left (RTE still reachable)
        if (pref->rte->prefixes) {
            // This RTE was using this prefix to advertise its Summ-LSA
            if (this_pref) {
                ospf->adv_best_prefix(pref->rte);
            }
        }

        prefixLSA->rte = 0;
        prefixLSA = 0;
    }
    // ASBR-LSA
    else if ((ls_id()>>24) == OPQ_T_MULTI_ASBR) {
        overlayAsbrLSA *ptr, *asbr = asbrLSA;
        overlayAsbrLSA **prev;

        if (!asbr->rte)
	        return;
            
        // Unlink from list in RTE
        for (prev = &asbr->rte->asbr_lsas; (ptr = *prev); prev = (overlayAsbrLSA **)&ptr->link) {
            if (*prev == asbr) {
                *prev = (overlayAsbrLSA *) asbr->link;
                break;
            }
        }

        asbrLSA->rte = 0;
        asbrLSA = 0;
    }
}