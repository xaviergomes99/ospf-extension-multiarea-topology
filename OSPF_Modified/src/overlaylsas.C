#include "ospfinc.h"
#include "monitor.h"
#include "system.h"
#include "ifcfsm.h"
#include "nbrfsm.h"
#include "phyint.h"

/* Constructor for the ABRrte
 */

ABRrte::ABRrte(uns32 _id) : RTE(_id, 0) 
{
}

/* Constructor for the ABR-LSA. We use the ABR-LSAs advertising router
 * as the unique key for the AVLitem, as we should only have one ABR-LSA
 * stored per existing ABR, generated by that same router.
 */

overlayAbrLSA::overlayAbrLSA(opqLSA *opq)
 : PriQElt(), AVLitem(opq->adv_rtr(), 0) 
{
    lsa = opq;
    opq->abrLSA = this;
    cost = LSInfinity;
    ospf->abrLSAs.add(this);
}

/* Destructor for the ABR-LSA
 */

overlayAbrLSA::~overlayAbrLSA()
{
    ospf->abrLSAs.remove(this);
}

/* Constructor for the Prefix-LSA
 */

overlayPrefixLSA::overlayPrefixLSA(opqLSA *opq, Prefixhdr *p)
 : AVLitem(opq->adv_rtr(), (p->subnet_addr & p->subnet_mask)) 

{
    lsa = opq;
    opq->prefixLSA = this;
    prefix = *p;
    ospf->prefixLSAs.add(this);
}

/* Destructor for the Prefix-LSA
 */

overlayPrefixLSA::~overlayPrefixLSA()
{
    ospf->prefixLSAs.remove(this);
}

/* Constructor for the ASBR-LSA
 */

overlayAsbrLSA::overlayAsbrLSA(opqLSA *opq, ASBRhdr *a)
 : AVLitem(opq->adv_rtr(), a->dest_rid)

{
    lsa = opq;
    opq->asbrLSA = this;
    asbr = *a;
    ospf->asbrLSAs.add(this);
}

/* Destructor for the ASBR-LSA
 */

overlayAsbrLSA::~overlayAsbrLSA()
{
    ospf->asbrLSAs.remove(this);
}

/* Constructor for the ABRNbr class. The area in which we are neighbors
 * with this ABR is used as a diferentiator for different objects
 * created for the same router. This is needed to store different possible
 * costs to the same ABR.
 */

ABRNbr::ABRNbr(rtid_t id, rtrLSA *lsa, SpfArea *a) : AVLitem(id, a->id()) {
    rid = id;
    rtr = lsa;
    cost = LSInfinity;
    area = a;
    ospf->ABRNbrs.add(this);
}

/* Destructor for the ABRNbr class
 */

ABRNbr::~ABRNbr() {
    ospf->ABRNbrs.remove(this);
    rtr->abr = 0;
}

/* We remove this neighbor ABR from our list of ABR overlay neighbors.
 * Also, we remove the link to this ABRNbr instance from the
 * corresponding Router-LSA.
 */

void ABRNbr::remove_abr_nb() {
    ospf->ABRNbrs.remove(this);
    rtr->abr = 0;
}

/* Add an ABR to OSPF. If already added, return it. Otherwise
 * allocate entry and add it to the AVL and singly linked list.
 * Similar to the method with the same name used inside the areas,
 * but to be used by the overlay ABRs.
 */

ABRrte *OSPF::add_abr(uns32 rtrid)

{
    ABRrte *rte;

    if ((rte = (ABRrte *) ABRtree.find(rtrid)))
        return(rte);
    
    rte = new ABRrte(rtrid);
    ABRtree.add(rte);
    return(rte);
}

/* We originate and flood our ABR-LSA inside an Opaque-LSA with
 * AS-scope. We go through all our ABR neighbors to whom the intra-area
 * shortest path cost has already been determined. We iterate through
 * two lists:
 *      - First, we go through all the entries for the ABRNbrs. Here
 *      we compare these entries to get only the lower cost entry for
 *      each neighboring ABR. The best option to each ABR is then stored
 *      in a separate list.
 *      - Then, we iterate through the list created that contains the
 *      lower path cost option to each ABR, to build the ABR-LSA.
 */

void OSPF::orig_abrLSA() {
    ABRNbr *abrNbr, *abr;
    ABRhdr *body, curr, body_start;
    AVLsearch iter(&ABRNbrs);
    int blen;
    lsid_t lsid;
    uns32 cost;
    uns32 rid;

    abr_changed = false;
    added_nbrs.clear();
    lsid = OPQ_T_MULTI_ABR << 24;
    body = &body_start;

    // Iterate through all ABR neighbor entries
    while ((abrNbr = (ABRNbr *) iter.next())) {
        cost = abrNbr->cost;
        rid = abrNbr->rid;
        // Cost is assigned, so we add to the LSA
        if (cost < LSInfinity) {
            // Entry already added
            if ((abr = (ABRNbr *) added_nbrs.find(rid))) {
                // Make sure it returns the correct one
                if (abr->get_rid() == rid) {
                    // There is an entry for this ABR with a lower or equal cost
                    if (abr->get_cost() <= cost)
                        continue;
                    // There is a better entry for an ABR already being advertised
                    else
                        added_nbrs.remove(abr);
                }
            }
            // New neighbor
            added_nbrs.add(abrNbr);
        }
    }

    // Add only the lower cost entries
    abrNbr = (ABRNbr *) added_nbrs.sllhead;
    for (; abrNbr; abrNbr = (ABRNbr *) abrNbr->sll) {
        curr.metric = abrNbr->cost;
        curr.neigh_rid = abrNbr->rid;
        memcpy(body, &curr, sizeof(ABRhdr));
        body++;
    }

    blen = added_nbrs.size() * sizeof(ABRhdr);
    if (blen > 0) {
        opq_orig(0, 0, LST_AS_OPQ, lsid, (byte *) &body_start, blen, true, 1);
        if (!first_abrLSA_sent) {
            first_abrLSA_sent = true;
            send_all_prefixes = true;
        }
    }
}

/* For a given routing table entry (referring to an intra-area destination)
 * we originate a Prefix-LSA and advertise it as an Opaque-LSA.
 */

void OSPF::orig_prefixLSA(INrte *rte) {
    Prefixhdr body;
    lsid_t lsid;

    lsid = (OPQ_T_MULTI_PREFIX << 24) | ((rte->uid << 8) >> 8);

    body.metric = rte->intra_cost;
    body.subnet_addr = hton32(rte->net());
    body.subnet_mask = hton32(rte->mask());

    opq_orig(0, 0, LST_AS_OPQ, lsid, (byte *) &body, sizeof(Prefixhdr), true, 1);
}

/* For a given ASBR (reachable through an area we are attached to)
 * we originate an ASBR-LSA and advertise it as an Opaque-LSA.
 */

void OSPF::orig_asbrLSA(ASBRrte *rte) {
    ASBRhdr body;
    lsid_t lsid;

    lsid = (OPQ_T_MULTI_ASBR << 24) | ((rte->uid << 8) >> 8);

    body.metric = rte->intra_cost;
    body.dest_rid = hton32(rte->rtrid());

    opq_orig(0, 0, LST_AS_OPQ, lsid, (byte *) &body, sizeof(ASBRhdr), true, 1);
}

/* We advertise all the current intra-area routes to prefixes and ASBRs
 * into the ABR overlay. We do that by (re)originating every Prefix-LSA and
 * ASBR-LSA available.
 */

void OSPF::advertise_all_prefixes() {
    INrte *rte;
    INiterator iter(inrttbl);
    ASBRrte *asbr;

    // We advertise our intra-area prefixes
    while ((rte = iter.nextrte())) {
        if ((rte->adv_overlay) &&
            (rte->has_intra_path && rte->intra_cost != LSInfinity))
            orig_prefixLSA(rte);
    }

    // We also advertise all routes to intra-area reachable ASBRs
    for (asbr = ASBRs; asbr; asbr = asbr->next()) {
        if ((asbr->adv_overlay) && 
            (asbr->has_intra_path && rte->intra_cost != LSInfinity))
            orig_asbrLSA(asbr);
    }

    ospf->send_all_prefixes = false;
}

/* Parse a received overlay-LSA.
 * This LSA can either be:
 *      - ABR-LSA
 *      - Prefix-LSA
 *      - ASBR-LSA
 * When parsing the LSA, we create the corresponding class object, if it doesn't
 * yet exist, in order to store the data from the LSA in a more useful manner
 */

void opqLSA::parse_overlay_lsa(LShdr *hdr) {
    // ABR-LSA
    if ((ls_id()>>24) == OPQ_T_MULTI_ABR) {
        overlayAbrLSA *abrLSA;

        if (!(abrLSA = (overlayAbrLSA *) ospf->abrLSAs.find(adv_rtr()))) {
            abrLSA = new overlayAbrLSA(this);
        }

        this->abrLSA = abrLSA;
        abrLSA->n_nbrs = (ntoh16(hdr->ls_length) - sizeof(LShdr))/sizeof(ABRhdr);
    }
    // Prefix-LSA
    else if ((ls_id()>>24) == OPQ_T_MULTI_PREFIX) {
        overlayPrefixLSA *prefLSA, *pref;
        Prefixhdr *prefhdr;
        //bool new_pref = false;

        prefhdr = (Prefixhdr *) (hdr+1);

        if (!(prefLSA = (overlayPrefixLSA *) ospf->prefixLSAs.find(adv_rtr(), (prefhdr->subnet_addr & prefhdr->subnet_mask)))) {
            prefLSA = new overlayPrefixLSA(this, prefhdr);
            //new_pref = true;
        }

        this->prefixLSA = prefLSA;

        prefLSA->rte = inrttbl->add(ntoh32(prefhdr->subnet_addr), ntoh32(prefhdr->subnet_mask));
        if (!prefLSA->rte->has_intra_path && !(prefLSA->rte->type() == RT_DIRECT))
            prefLSA->rte->r_type = RT_SPFIA;
        prefLSA->prefix = *prefhdr;

        // Link this prefix-LSA to the list of prefix-LSAs associated to this prefix
        //if (new_pref) {
            prefLSA->link = prefLSA->rte->prefixes;
            prefLSA->rte->prefixes = prefLSA;
        //}
        
        // Originate the corresponding summ-LSA, if there isn't a 
        // full overlay calculation scheduled
        if (ospf->first_abrLSA_sent && !ospf->calc_overlay && (ospf->n_overlay_dijkstras > 0)) {
            uns32 best_cost = LSInfinity, cost;
            bool found = false;
            overlayAbrLSA *abr;
            // rtid_t rid;
            for (pref = prefLSA->rte->prefixes; pref; pref = (overlayPrefixLSA *) pref->link) {
                if ((abr = (overlayAbrLSA *) ospf->abrLSAs.find(pref->index1()))) {
                    found = true;
                    cost = abr->cost + pref->prefix.metric;
                    if (cost < best_cost) {
                        best_cost = cost;
                        // rid = abr->index1();
                    }
                }
            }
            // Assign the best cost to the routing table entry and
            // generate the corresponding Summ-LSA, if the cost has changed
            if (found && (prefLSA->rte->cost != best_cost || !prefLSA->rte->has_been_adv)) {
                prefLSA->rte->cost = best_cost;
                prefLSA->rte->has_been_adv = true;
                ospf->sl_orig(prefLSA->rte);
                // if (rid != ospf->my_id())
                //     prefLSA->rte->waiting_for_summ = true;
            }
        }
    }
    // ASBR-LSA
    else if ((ls_id()>>24) == OPQ_T_MULTI_ASBR) {
        overlayAsbrLSA *asbrLSA, *asbr;
        ASBRhdr *asbrhdr;

        asbrhdr = (ASBRhdr *) (hdr+1);

        if (!(asbrLSA = (overlayAsbrLSA *) ospf->asbrLSAs.find(adv_rtr(), asbrhdr->dest_rid))) {
            asbrLSA = new overlayAsbrLSA(this, asbrhdr);
        }

        this->asbrLSA = asbrLSA;

        asbrLSA->rte = ospf->add_asbr(asbrhdr->dest_rid);
        if (!asbrLSA->rte->has_intra_path && asbrLSA->rte->type() != RT_DIRECT)
            asbrLSA->rte->r_type = RT_SPFIA;
        asbrLSA->asbr = *asbrhdr;

        asbrLSA->link = asbrLSA->rte->asbr_lsas;
        asbrLSA->rte->asbr_lsas = asbrLSA;

        // Originate the corresponding ASBR-Summ-LSA, if there isn't a 
        // full overlay calculation scheduled
        if (ospf->first_abrLSA_sent && !ospf->calc_overlay && (ospf->n_overlay_dijkstras > 0)) {
            uns32 best_cost = LSInfinity, cost;
            bool found = false;
            overlayAbrLSA *abr;
            // rtid_t rid;
            for (asbr = asbrLSA->rte->asbr_lsas; asbr; asbr = (overlayAsbrLSA *) asbr->link) {
                if ((abr = (overlayAbrLSA *) ospf->abrLSAs.find(asbr->index1()))) {
                    found = true;
                    cost = abr->cost + asbr->asbr.metric;
                    if (cost < best_cost) {
                        best_cost = cost;
                        // rid = abr->index1();
                    }
                }
            }
            // Assign the best cost to the routing table entry and
            // generate the corresponding ASBR-Summ-LSA, if the cost has changed
            if (found && (asbrLSA->rte->cost != best_cost || !asbrLSA->rte->has_been_adv)) {
                asbrLSA->rte->cost = best_cost;
                asbrLSA->rte->has_been_adv = true;
                ospf->asbr_orig(asbrLSA->rte);
                // if (rid != ospf->my_id())
                //     asbrLSA->rte->waiting_for_summ = true;
            }
        }
    }
}

/* Unparse an overlay-LSA
 */

void opqLSA::unparse_overlay_lsa() {
    // ABR-LSA
    if ((ls_id()>>24) == OPQ_T_MULTI_ABR) {
        abrLSA->n_nbrs = 0;
        // abrLSA->nbrs = 0;
        abrLSA = 0;
    }
    // Prefix-LSA
    else if ((ls_id()>>24) == OPQ_T_MULTI_PREFIX) {
        prefixLSA->rte = 0;
        prefixLSA = 0;

        overlayPrefixLSA *ptr, *pref = prefixLSA;
        overlayPrefixLSA **prev;

        if (!pref->rte)
	        return;

        // Unlink from list in RTE
        for (prev = &pref->rte->prefixes; (ptr = *prev); prev = (overlayPrefixLSA **)&ptr->link) {
            if (*prev == pref) {
	            *prev = (overlayPrefixLSA *) pref->link;
	            break;
	        }
        }
    }
    // ASBR-LSA
    else if ((ls_id()>>24) == OPQ_T_MULTI_ASBR) {
        asbrLSA->rte = 0;
        asbrLSA = 0;
        
        overlayAsbrLSA *ptr, *asbr = asbrLSA;
        overlayAsbrLSA **prev;

        if (!asbr->rte)
	        return;
            
        // Unlink from list in RTE
        for (prev = &asbr->rte->asbr_lsas; (ptr = *prev); prev = (overlayAsbrLSA **)&ptr->link) {
            if (*prev == asbr) {
                *prev = (overlayAsbrLSA *) asbr->link;
                break;
            }
        }
    }
}